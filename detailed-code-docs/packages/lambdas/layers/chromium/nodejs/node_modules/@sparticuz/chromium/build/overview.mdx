---
title: "Overview"
---

## High-level description
This directory contains the core functionality for managing Chromium in serverless environments, particularly AWS Lambda and Google Cloud Functions. It provides utilities for setting up Chromium, handling fonts, configuring the browser, and decompressing necessary files in a Lambda environment.

## What does it do?
The code in this directory enables developers to run Chromium in serverless environments by:

1. Setting up the Chromium environment, including inflating the Chromium binary and related files.
2. Managing custom fonts for use with Chromium.
3. Providing recommended command-line arguments and viewport settings for Chromium in serverless contexts.
4. Decompressing and extracting compressed files (Brotli, Gzip, and tarballs) needed for Chromium operation.

These functionalities allow developers to use Chromium for tasks like web scraping, PDF generation, or running automated tests in serverless environments where traditional browser setups are not possible.

## Key Files

### index.js
This file defines the `Chromium` class, which is the main interface for managing Chromium in serverless environments. Key features include:

- `Chromium.font(input)`: Handles custom font management.
- `Chromium.args`: Provides recommended Chromium command-line arguments.
- `Chromium.defaultViewport`: Offers default viewport settings.
- `Chromium.executablePath`: Inflates and returns the path to the Chromium binary.
- `Chromium.headless`: Determines if running in a serverless environment.

Example usage:
```javascript
const chromium = require('@sparticuz/chromium');

async function setupChromium() {
  const executablePath = await Chromium.executablePath;
  const browser = await puppeteer.launch({
    args: Chromium.args,
    defaultViewport: Chromium.defaultViewport,
    executablePath,
    headless: Chromium.headless,
  });
  // Use the browser instance for further operations
}
```

### lambdafs.js
This file contains the `LambdaFS` class, which provides file system operations specific to Lambda environments. The main functionality is:

- `LambdaFS.inflate(filePath)`: Decompresses and extracts compressed files, handling Brotli, Gzip, and tarballs.

Example usage:
```javascript
const LambdaFS = require('./lambdafs');

async function extractChromiumFiles() {
  const chromiumPath = '/path/to/compressed/chromium';
  const extractedPath = await LambdaFS.inflate(chromiumPath);
  console.log(`Chromium extracted to: ${extractedPath}`);
}
```

## Dependencies
The codebase relies on several external libraries and Node.js built-in modules:

1. fs: For file system operations.
2. path: For file path manipulations.
3. url: For URL parsing and manipulation.
4. os: For operating system-related utilities.
5. zlib: For compression/decompression utilities.
6. tar-fs: For handling tar archives.

These dependencies are chosen to provide efficient file handling, compression/decompression, and path manipulation capabilities, which are crucial for managing Chromium in serverless environments.

## Configuration
The code uses environment variables to detect the serverless environment and configure its behavior:

- `AWS_LAMBDA_FUNCTION_VERSION`: Indicates an AWS Lambda environment.
- `FUNCTION_NAME`: Indicates a Google Cloud Functions environment.
- `FONTCONFIG_PATH`: Used for font configuration.
- `LD_LIBRARY_PATH`: Used for library path configuration.

The code also uses specific file paths and directories for its operations:

- `/tmp`: Used for storing inflated Chromium files and fonts in serverless environments.
- `/opt/lib`: Used as a fallback library path.

## Performance Considerations
1. The code caches the inflated Chromium binary and related files in the `/tmp` directory to improve performance in subsequent invocations in serverless environments.
2. For file decompression, the code uses optimized buffer sizes:
   - A high water mark of 2^23 bytes for reading large files.
   - A chunk size of 2^21 bytes for Brotli and Gzip decompression.

These optimizations help in efficiently handling large files and improving the overall performance of Chromium setup in serverless environments.

In conclusion, this directory provides a robust solution for running Chromium in serverless environments, handling the complexities of file management, compression, and browser configuration to enable advanced web automation tasks in cloud functions.