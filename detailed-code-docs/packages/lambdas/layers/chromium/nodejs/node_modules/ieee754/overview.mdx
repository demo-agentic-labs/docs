---
title: "Overview"
---

## High-level description
This directory contains the `ieee754` npm package, which provides functionality to read and write IEEE 754 floating-point numbers from/to a Buffer or array-like object. The package is authored by Feross Aboukhadijeh and is licensed under the BSD-3-Clause license.

## What does it do?
The `ieee754` package implements two main functions:

1. `read`: This function converts a binary representation stored in a buffer into a floating-point number according to the IEEE 754 standard. It can handle different endianness (little-endian or big-endian), various mantissa lengths, and different total byte sizes.

2. `write`: This function does the opposite of `read`. It takes a floating-point number and writes its binary representation into a buffer according to the IEEE 754 standard. Like `read`, it can handle different endianness, mantissa lengths, and byte sizes.

These functions are particularly useful when working with binary data formats that include floating-point numbers, such as in network protocols, file formats, or low-level system interactions.

## Key Files

1. `index.js`: This is the main file of the package, containing the implementation of the `read` and `write` functions. Here's a brief overview of these functions:

   - `read(buffer, offset, isLE, mLen, nBytes)`: 
     - Reads a floating-point number from the buffer.
     - `buffer`: The source buffer.
     - `offset`: Starting position in the buffer.
     - `isLE`: Boolean indicating if the buffer is in little-endian format.
     - `mLen`: Length of the mantissa in bits.
     - `nBytes`: Total number of bytes to read.

   - `write(buffer, value, offset, isLE, mLen, nBytes)`:
     - Writes a floating-point number to the buffer.
     - `buffer`: The target buffer.
     - `value`: The floating-point number to encode.
     - Other parameters are similar to `read`.

   Both functions handle special cases like NaN, Infinity, and zero, and perform bit-level operations for efficiency.

2. `index.d.ts`: This file contains TypeScript type definitions for the package, enhancing type safety and IDE support for TypeScript users.

3. `package.json`: This file contains metadata about the package, including version information, dependencies, scripts, and more.

## Dependencies
The package has no runtime dependencies, relying only on JavaScript's built-in `Math` object. However, it does have several development dependencies:

- `airtap`: Used for browser testing.
- `standard`: Likely used for code linting and style checking.
- `tape`: Used for running tests.

## Configuration
The package doesn't require any specific configuration. It's designed to be used as-is, with the `read` and `write` functions accepting parameters that determine how they should operate (e.g., endianness, mantissa length, total bytes).

## Performance Considerations
The `read` and `write` functions are implemented using bit manipulation and low-level operations for efficiency. They avoid creating unnecessary objects or arrays, operating directly on the input buffer. This approach minimizes memory allocation and provides good performance for operations that might be performed frequently in certain applications.

## Error Handling
The code doesn't implement explicit error handling. It assumes correct input parameters and relies on JavaScript's behavior for invalid operations (e.g., returning NaN for certain calculations). Users of this package should be aware of this and implement their own error checking if necessary.

## Usage Example
Here's a simple example of how to use the `ieee754` package:

```javascript
const ieee754 = require('ieee754')

// Create a buffer
const buffer = Buffer.alloc(4)

// Write a float to the buffer
ieee754.write(buffer, 3.14, 0, true, 23, 4)

// Read the float back from the buffer
const value = ieee754.read(buffer, 0, true, 23, 4)

console.log(value) // Output: 3.140000104904175
```

This example writes the number 3.14 to a buffer as a 32-bit float (4 bytes, 23-bit mantissa) in little-endian format, then reads it back. The slight discrepancy in the output is due to the limited precision of 32-bit floats.