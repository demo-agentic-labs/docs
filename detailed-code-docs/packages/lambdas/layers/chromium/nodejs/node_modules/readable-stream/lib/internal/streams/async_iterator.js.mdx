---
title: "async_iterator.js"
---

## High-level description
This code implements an async iterator for readable streams in Node.js. It allows for asynchronous iteration over stream data using the `for await...of` syntax or manual calls to `next()`. The implementation handles various edge cases, including stream errors, premature closing, and multiple concurrent `next()` calls.

## Code Structure
The main function `createReadableStreamAsyncIterator` creates and returns an iterator object. This object is based on the `ReadableStreamAsyncIteratorPrototype`, which defines the core functionality of the iterator. Several helper functions (`readAndResolve`, `onReadable`, `wrapForNext`) support the main iterator operations.

## Symbols
### `createReadableStreamAsyncIterator`
#### Description
Creates and returns an async iterator for a given readable stream.

#### Inputs
| Name | Type | Description |
|:-----|:-----|:------------|
| stream | ReadableStream | The stream to iterate over |

#### Outputs
| Name | Type | Description |
|:-----|:-----|:------------|
| iterator | Object | An async iterator for the given stream |

#### Internal Logic
1. Creates an iterator object with properties for managing the iteration state.
2. Sets up error handling and end-of-stream detection using the `finished` function.
3. Attaches a 'readable' event listener to the stream.
4. Returns the created iterator.

### `ReadableStreamAsyncIteratorPrototype`
#### Description
Defines the prototype for the async iterator, including methods for `next()`, `return()`, and `Symbol.asyncIterator`.

#### Internal Logic
- `next()`: Handles the core iteration logic, including error checking, end-of-stream detection, and reading from the stream.
- `return()`: Implements the logic for prematurely ending the iteration and destroying the stream.
- `Symbol.asyncIterator`: Returns the iterator itself, making it compatible with `for await...of` loops.

### `readAndResolve`
#### Description
Attempts to read data from the stream and resolve the current promise if data is available.

#### Inputs
| Name | Type | Description |
|:-----|:-----|:------------|
| iter | Object | The iterator object |

### `onReadable`
#### Description
Callback function for the 'readable' event, which triggers `readAndResolve` on the next tick.

#### Inputs
| Name | Type | Description |
|:-----|:-----|:------------|
| iter | Object | The iterator object |

### `wrapForNext`
#### Description
Creates a wrapper function for handling multiple `next()` calls, ensuring they are processed sequentially.

#### Inputs
| Name | Type | Description |
|:-----|:-----|:------------|
| lastPromise | Promise | The previous promise in the chain |
| iter | Object | The iterator object |

#### Outputs
| Name | Type | Description |
|:-----|:-----|:------------|
| function | Function | A wrapper function for the next promise |

## Dependencies
| Dependency | Purpose |
|:-----------|:--------|
| './end-of-stream' | Provides the `finished` function for handling stream completion |

## Error Handling
The code implements error handling by:
1. Checking for errors in the `next()` method and rejecting the promise if an error is detected.
2. Using the `finished` function to handle stream errors and premature closing.
3. Storing errors in the iterator's `kError` property for future rejection.

## Performance Considerations
The implementation optimizes for the common case of sequential `next()` calls, as typically used in `for await...of` loops. It includes a fast path for when data is immediately available, avoiding unnecessary promise creation.

This code is a crucial part of Node.js's stream implementation, providing an efficient and standardized way to consume readable streams asynchronously.